# Отчет по лабораторной работе: "Многопоточное программирование на C"

## Выполненные задания

### 1. Создание потока
Реализовано создание дочернего потока с помощью `pthread_create()`. Оба потока (родительский и дочерний) выводят по 5 строк текста.

**Особенности реализации:**
- Использованы атрибуты потока по умолчанию
- Демонстрация параллельного выполнения потоков

### 2. Ожидание потока
Модификация первого задания с использованием `pthread_join()` для ожидания завершения дочернего потока перед выводом текста родительским потоком.

### 3. Параметры потока
Создано 4 потока, каждый из которых получает свой набор строк для вывода через параметры.

**Ключевые моменты:**
- Передача параметров через указатель
- Различные сообщения для каждого потока

### 4. Завершение потока без ожидания
Реализовано принудительное завершение дочерних потоков через 2 секунды с помощью `pthread_cancel()`.

### 5. Обработка завершения потока
Добавлены обработчики завершения с использованием `pthread_cleanup_push()`, которые выводят сообщение перед завершением потока.

### 6. Sleepsort
Реализован алгоритм Sleepsort:
- Создается отдельный поток для каждого элемента массива
- Каждый поток "засыпает" на время, равное значению элемента
- После пробуждения выводит значение элемента

### 7. Синхронизированный вывод
Реализована синхронизация вывода между родительским и дочерними потоками с использованием мьютексов и условных переменных.

### 8. Перемножение матриц
Реализовано параллельное перемножение матриц с:
- Разделением работы между потоками
- Обработкой случаев, когда размер матрицы не кратен числу потоков
- Выводом результатов для небольших матриц

### 9. Анализ производительности
Проведены замеры времени выполнения для разных размеров матриц (до 2500x2500) и разного количества потоков (1-128). Результаты представлены на графике:

![График зависимости времени выполнения от размера матрицы и количества потоков](Figure_1.png)

## Выводы

1. Многопоточность позволяет значительно ускорить вычисления для задач с высокой вычислительной сложностью
2. Оптимальное количество потоков зависит от размера задачи и характеристик процессора
3. Синхронизация потоков требует аккуратной работы с примитивами синхронизации
4. Алгоритм Sleepsort демонстрирует необычный подход к сортировке, хотя и не является практичным для реального использования
5. Перемножение матриц хорошо поддается распараллеливанию, особенно для больших размеров матриц

## Приложения

### Исходный код
Полный исходный код всех реализаций прилагается к отчету.

### Графики производительности
Графики показывают зависимость времени выполнения от:
- Размера матрицы
- Количества потоков
